package algorithm;

/**
 * ClassName: QuickSort
 * Description:
 * date: 2020/11/10 0:19
 *
 * @author ZhangShunshengs
 * @since JDK 1.8
 */
public final class QuickSort {

    /*
        普通快速排序：
            核心思想 -- 分治、递归。将待排序数组根据一个基准数分为两部分，使两边的所有数分别均
                大于或者小于基准数，再递归将其细分，到最下面的时候，每一组数分完都会形成有序数组，
                从而形成一个有序数组。
            时间复杂度
                快速排序涉及到递归调用，所以该算法的时间复杂度还需要从递归算法的复杂度开始说起；
                递归算法的时间复杂度公式：T[n] = aT[n/b] + f(n)  ；对于递归算法的时间复杂度这里
                就不展开来说了；
            最优情况下时间复杂度
                   快速排序最优的情况就是每一次取到的元素都刚好平分整个数组；
                此时的时间复杂度公式则为：T[n] = 2T[n/2] + f(n)；T[n/2]为平分后的子数组的时间复杂度，f[n] 为平分这个数组时所花的时间；
                下面来推算下，在最优的情况下快速排序时间复杂度的计算(用迭代法)：
                                                  T[n] =  2T[n/2] + n                                                                     ----------------第一次递归
                         令：n = n/2        =  2 { 2 T[n/4] + (n/2) }  + n                                               ----------------第二次递归
                                                    =  2^2 T[ n/ (2^2) ] + 2n
                        令：n = n/(2^2)   =  2^2  {  2 T[n/ (2^3) ]  + n/(2^2)}  +  2n                         ----------------第三次递归
                                                    =  2^3 T[  n/ (2^3) ]  + 3n
                        令：n = n/(  2^(m-1) )    =  2^m T[1]  + mn                                                  ----------------第m次递归(m次后结束)
                       当最后平分的不能再平分时，也就是说把公式一直往下跌倒，到最后得到T[1]时，说明这个公式已经迭代完了（T[1]是常量了）。
                       得到：T[n/ (2^m) ]  =  T[1]    ===>>   n = 2^m   ====>> m = logn；
                       T[n] = 2^m T[1] + mn ；其中m = logn;
                       T[n] = 2^(logn) T[1] + nlogn  =  n T[1] + nlogn  =  n + nlogn  ；其中n为元素个数
                       又因为当n >=  2时：nlogn  >=  n  (也就是logn > 1)，所以取后面的 nlogn；
                       综上所述：快速排序最优的情况下时间复杂度为：O( nlogn )
            最差情况下时间复杂度
                    最差的情况就是每一次取到的元素就是数组中最小/最大的，这种情况其实就是冒泡排序了(每一次都排好一个元素的顺序)
                 这种情况时间复杂度就好计算了，就是冒泡排序的时间复杂度：T[n] = n * (n-1) = n^2 + n;
                 综上所述：快速排序最差的情况下时间复杂度为：O( n^2 )
            平均时间复杂度
                    快速排序的平均时间复杂度也是：O(nlogn)
            空间复杂度
                    其实这个空间复杂度不太好计算，因为有的人使用的是非就地排序，那样就不好计算了（因为有的人用到了辅助数组，所以这就要计算到你的元素个数了）；我就分析下就地快速排序的空间复杂度吧；
                    首先就地快速排序使用的空间是O(1)的，也就是个常数级；而真正消耗空间的就是递归调用了，因为每次递归就要保持一些数据；
                 最优的情况下空间复杂度为：O(logn)  ；每一次都平分数组的情况
                 最差的情况下空间复杂度为：O( n )      ；退化为冒泡排序的情况
     */

    /*
        快速排序的几种优化方法：
            1、固定取值法（数组随机，基准值选取固定位置的）
            2、三数取中（选取首、中、尾三个元素的中间值作为基准值）
            3、三数 + 插入排序
            4、三数 + 插入排序 + 尾递归
            5、三数 + 插入排序 + 多线程
            6、三数 + 插入排序 + 聚集元素（每次划分将与基准值相同的元素放在首尾两边，再继续递归前移至基准值两侧，跳过进而继续递归）
          *注：尾递归
                概念：
                    如果一个函数中所有递归形式的调用都出现在函数的末尾，我们称这个递归函数是尾递归的。
                当递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分时，这个递归调
                用就是尾递归。尾递归函数的特点是在回归过程中不用做任何操作，这个特性很重要，因为大多
                数现代的编译器会利用这种特点自动生成优化的代码。
                原理：
                    当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创
                建一个新的。编译器可以做到这点，因为递归调用是当前活跃期内最后一条待执行的语句，于是
                当这个调用返回时栈帧中并没有其他事情可做，因此也就没有保存栈帧的必要了。通过覆盖当前
                的栈帧而不是在其之上重新添加一个，这样所使用的栈空间就大大缩减了，这使得实际的运行效
                率会变得更高。
     */

    /**
     * 普通快速排序算法
     * @param array 待排序数据
     * @param start 排序下标
     * @param end 排序上标
     */
    public static void commonQuickSortAlgorithms(int[] array, int start, int end) {
        if(start == end || end - start < 2) {
            return;
        }
        int temp = array[start];
        int baseIndex = start;
        int finalIndex = end;
        while(finalIndex > baseIndex) {
            if(array[finalIndex] < temp) {
                array[baseIndex] = array[finalIndex];
                array[finalIndex] = array[baseIndex + 1];
                baseIndex++;
            } else {
                finalIndex--;
            }
        }
        array[baseIndex] = temp;
        commonQuickSortAlgorithms(array, start, baseIndex);
        commonQuickSortAlgorithms(array, baseIndex + 1, end);
    }

}
